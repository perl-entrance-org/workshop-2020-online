# Perl入学式

## 第4回 リファレンス編

___
## 諸注意
- 会場について
    - 飲食・喫煙・トイレetc

- 写真撮影について
    - 写真撮影NGな方は、お手数ですが申し出てください

    - 写真はPerl普及団体の [JPA ( Japan Perl Association )](https://japan.perlassociation.org/)への活動報告に利用します

___
## 講師紹介

- 講師・サポーター紹介

___
## 皆さんで自己紹介
- せっかく今日集まったので、テーブルで自己紹介をしましょう。

- 話題は自由ですが、以下がオススメです。

    - 名前(ハンドルネーム)

    - なぜPerlを勉強してみようと思ったか

    - なぜPerl入学式に参加してみようと思ったか

    - 前回参加してからの学習の進捗

___
## 今日の流れ
- 前回の復習
- リファレンス、その前に
- 配列リファレンス
- 配列リファレンスの応用
- 配列リファレンスを使う
- ハッシュリファレンス
- ハッシュリファレンスの応用
- ハッシュリファレンスを使う
- HTML入学式

___
# 前回の復習

- ハッシュ

- 正規表現

---
# リファレンス <br> その前に

___
## リファレンス、その前に
### 第2回：スカラー変数
```perl
my $scalar = 'Hello world';
print $scalar . "\n";    # Hello world

my $num = 1;
$num = $num + 1;
print $num . "\n";   # 2
```

___
## リファレンス、その前に
### 第2回：配列
```perl
my @number_array = ( 1, 2, 3, 4, 5 );
print "@number_array\n";    # 1 2 3 4 5

my @strings_array = ( 'Jan', 'Feb', 'Mar', 'Apr', 'May' );
print "@strings_array\n";    # Jan Feb Mar Apr May
```

___
## リファレンス、その前に
### 第3回：ハッシュ
```perl
my %hash = (
    Perl  => 'Larry Wall',
    PHP   => 'Rasmus Lerdorf',
    C     => 'Dennis MacAlistair Ritchie',
    swift => 'Chris Lattner'
);

for my $lang ( sort keys %hash ) {
    print $lang . ' was made by ' . $hash{$lang} . "\n";
}
```

___
## リファレンス、その前に
### データ と データ構造
これからの説明では、変数の中に入れてきた「文字列」や「数値」を **データ** と呼びます。

また、データを 「 親 - 子 」関係や「含む - 含まれる」など、データ同士を関連づけたものを **データ構造** と呼びます。

といっても、難しい話ではありません。

我々はすでにデータ構造の中で、その概念をつかって便利に暮らしています。

___
## リファレンス、その前に
### 身近なデータ構造
２頭の犬がいて、それぞれに名前が付いている。また、それぞれの犬種についての情報も含まれている。

- 犬
    - 名前 : タロ { 種別 : 柴犬 , 色 : 茶色}
    - 名前 : チョビ { 種別 : ハスキー , 色 : 白黒 }

___
## リファレンス、その前に
### 身近なデータ構造
馬の名前と、両親、母の父親（祖父）の情報

- 名前 : トウカイテイオー
    - 父 : シンボリルドルフ
    - 母 : トウカイナチュラル
        - 母の父 : ナイスダンサー

___
## リファレンス、その前に
### 複雑なデータ構造
このように、実際に我々が利用しているデータ構造ですが、これまで学習してきたスカラー変数、配列、ハッシュ だけでは再現しきれない状況があります。

例えば、日本の都道府県を配列で再現してみます。

```
日本 =  ( 北海道, ... 東京都, 大阪府, ... 福岡県, 沖縄県 );
```

```perl
# Perl入学式を開催している都道府県
my @japan = ( 'Hokkaido',
              'Tokyo',
              'Osaka',
              'Fukuoka',
              'Okinawa',
            );
```

___
## リファレンス、その前に
### 複雑なデータ構造
東京には23区があります

日本の都道府県を羅列した配列の中に、東京（親） - 23区（子）という関係を維持したデータ構造を作ってみましょう。

```perl
# Perl入学式を開催している都道府県
my @japan = ('Hokkaido', 'Tokyo', 'Osaka', 'Fukuoka', 'Okinawa');

# 東京23区の一部
my @tokyo = ('Chiyoda', 'Shinagawa', 'Shinjyuku', 'Taito');

push @japan, @tokyo;
print "@japan\n";   # Hokkaido Tokyo Kyoto Osaka Fukuoka Okinawa Chiyoda Shinagawa Shinjyuku Taito
```

23区の情報が `@japan` の中で展開され、東京(親) - 23区(子) という親子関係がわからなくなってしまいました。

___
## リファレンス、その前に
### 複雑なデータ構造
先の例の通り、現時点で学んだ「スカラー変数」「配列」「ハッシュ」だけでは以下のデータ構造を作ることができません。

- 配列の中の配列

- 配列の中のハッシュ

- ハッシュの中の配列

- ハッシュの中のハッシュ

___
## リファレンス、その前に
### 複雑なデータ構造
このような複雑なデータ構造を表現し、利用するための方法が **リファレンス** です。

---
# リファレンス

___
## リファレンス
### リファレンスでできること
先に説明してきた複雑なデータ構造は **リファレンス** を利用することで再現が可能です。

リファレンスとは、変数の中のデータそのものではなく、 **データを指し示すもの** です。

例えば我々もデータを指し示す際に、以下のようにリファレンスを使っています。

- 名前やIDをつかって特定の人物を指し示す。

- GPS座標をつかって特定の場所を指し示す。

この場合、**データを指し示すもの** は名前やGPS座標です。

___
## リファレンス
### リファレンスの作り方
変数の先頭についているシジル（ $, @, % ）の前にバックスラッシュ (\\) を置くことで、 それぞれの変数をリファレンスにすることができます。
```perl
my $scalar     = 'scalar';    # スカラーを定義
my $scalar_ref = \$scalar;    # スカラーのリファレンスを作成

my @array = ( 'foo', 'bar', 'baz' );    # 配列を定義
my $array_ref = \@array;    # 配列のリファレンスを作成

my %hash = ( foo => 'bar' );    # ハッシュを定義
my $hash_ref = \%hash;    # ハッシュのリファレンスを作成
```

それぞれのリファレンスを格納しているのが **スカラー変数** であることに注目してください。
配列とハッシュをスカラー変数にすることで、配列の要素やハッシュの値にすることが可能になります。

___
## リファレンス
### ここまでのまとめ
1. Perlの配列やハッシュには、スカラー値しか格納できない。このため、複雑なデータ構造を作ることができない。

1. 配列やハッシュを **リファレンス** にすることで、スカラー値にすることができる。

1. リファレンスを利用することで、以下のような複雑なデータ構造を表現できる。
    - 配列の中の配列
    - 配列の中のハッシュ
    - ハッシュの中の配列
    - ハッシュの中のハッシュ

___
## リファレンス
### 補足
なお、リファレンスを作ることを **リファレンス化** 、 **リファレンスをとる** ともいいます。

次項からは、配列リファレンスを例にとって解説していきます。

---
# 配列リファレンス

___
## 配列リファレンス
### 配列リファレンスの中身
ここからは配列リファレンスを例に説明していきます。

作成したリファレンスをそのまま `print` してみます。

```perl
my @array = ( 'foo', 'bar', 'baz' );    # 配列を定義
my $array_ref = \@array;    # 配列のリファレンスを作成
print "$array_ref\n";       # ARRAY(0x7fba31013488)
```

この時、1行に2つの情報が表示されています。

- リファレンスにする前の変数の種類（ SCALAR, ARRAY, HASH など ）

- リファレンスにする前の変数の値が格納されている **メモリの番地**

メモリは **コンピュータの一時的な記憶場所** と考えてください。
（一時的なので実行ごとにメモリの番地が変わります）

メモリの番地は重複することのない、1つの値（スカラー値）です。

___
## 配列リファレンス
### 配列リファレンスの中身
リファレンスは「メモリの番地」が格納されているスカラー変数、と解説しました。

配列やハッシュなどは複数の要素を持ちますが、コンピュータ上ではこれを１つのメモリの番地に格納します。

このメモリの番地は重複することはありません。

これらの配列やハッシュをリファレンスにして「１つのメモリの番地」、つまり「１つの値」にすることで、スカラー変数に格納することが可能です。

___
## 配列リファレンス
### デリファレンス
スカラー変数にした配列やハッシュですが、必要に応じて元の変数に戻す必要があります。

そのために行うのが **デリファレンス** です。

リファレンスが格納されている変数を `{ }` （中括弧, curly bracket）で囲み、元の変数のシジルをつけることでデリファレンスすることが可能です。

```perl
my @array = ( 'foo', 'bar', 'baz' );    # 配列を定義
my $array_ref = \@array;    # 配列のリファレンスを作成
print $array_ref . "\n";    # メモリの番地 ARRAY(0x7ffa86818118)

my @deref_array = @{$array_ref};    # デリファレンスして新しい配列に入れた
print "@deref_array\n";      # foo bar baz
```

___
## 配列リファレンス
### デリファレンスする
先ほど出てきた `@{$array_ref}` について説明します。`{ }` の中から見ていきます。

```perl
    my @deref_array = @{$array_ref};    # デリファレンスして新しい配列に入れた
```

1. `$array_ref` ：スカラー変数（中身は配列リファレンス）

1. `@{$array_ref}` ： スカラー変数を `{ }` で囲み、元の配列のシジル `@` をつけてデリファレンスした。

デリファレンスした `@{$array_ref}` は配列と同様に扱うことができるので、新しい配列変数 `@deref_array` に代入が可能です。

___
## 配列リファレンス
### デリファレンス
デリファレンスしたスカラー変数は、元の配列と等価です。

```perl
my @array = ( 'foo', 'bar', 'baz' );    # 配列を定義
my $array_ref = \@array;    # 配列のリファレンスを作成

print "@array\n";           # foo bar baz
print "@{$array_ref}\n";    # foo bar baz
```

___
## 配列リファレンス
### デリファレンス
デリファレンスしたスカラー変数は、配列と同じように添字を使って元の配列の要素にアクセスできます。

```perl
my @array = ( 'foo', 'bar', 'baz' );    # 配列を定義
my $array_ref = \@array;    # 配列のリファレンスを作成

# @{$array_ref}    : 配列リファレンスをデリファレンスしたもの
# ${$array_ref}[0] : 配列リファレンスをデリファレンスして１つの要素を指定
#                  : １つの要素を扱うときのシジルは $ になることに注意

print "${$array_ref}[0]\n"; # foo
print "${$array_ref}[1]\n"; # bar
print "${$array_ref}[2]\n"; # baz
```

___
## 練習問題(deref_array_1.pl)
以下のコードを実行するとエラーが出ます。エディタにコピペしたうえで修正し、プログラムを完成させてください。
```perl
#!/usr/bin/env perl
use strict;
use warnings;

my @array = ( 1 .. 100 );           # 1から100までの数字が格納された配列を用意する
my $array_ref   =  @array;          # 配列リファレンスを作成する
my @deref_array = @{$array_ref};    # 配列リファレンスをデリファレンスする

print "@deref_array\n";             # 1から100までの数字が表示されると正解
```

___
## 練習問題(deref_array_2.pl)
以下のコードを実行するとエラーが出ます。エディタにコピペしたうえで**if文の条件式を修正し**、プログラムを完成させてください。

```perl
#!/usr/bin/env perl
use strict;
use warnings;

my @array = ( 'A' .. 'Z' ); # A から Z までの文字が格納された配列を用意する
my $array_ref = \@array;    # 配列リファレンスを作成する

if ( $array_ref[10] eq 'K' ) {
    print "配列の先頭から10番目の要素はKです"; # この行が実行されると正解
}
```

---
# 配列リファレンスの応用

___
## 配列リファレンスの応用
### 簡単な作り方
すでに複雑なデータ構造を作ることが決まっている場合、 **無名配列** を使うことで一手間省くことが可能です。

```perl
# これまでの方法
my @array      = ( 'foo', 'bar', 'baz' ); # リファレンスの元になる配列
my $array_ref  = \@array;                 # リファレンスにして スカラー変数に格納する

# 無名配列を使う方法
my $anonymous_array  = [ 'foo', 'bar', 'baz' ];
```

無名配列の「無名」は配列としての名を持たない（`$anonymous_array` はスカラーの名前）と考えてください。

通常の配列作成時は `( )` を利用しますが、無名配列は **`[ ]` （角括弧, square brackets）を利用して作成します。**

___
## 配列リファレンスの応用
### 簡単な参照法
簡単な参照の仕方を紹介する前に、従来の方法を復習しておきます。

（参考）配列の0番目の要素を表示する
```perl
my @array      = ( 'foo', 'bar', 'baz' );
print "$array[0]\n";    # foo
```

（参考）配列リファレンスの0番目の要素を表示する（デリファレンスして添字）
```perl
my $array_ref = [ 'foo', 'bar', 'baz' ];    # 無名配列
print "${$array_ref}[0]\n";                 # foo デリファレンスして添字
```

___
## 配列リファレンスの応用
### 簡単な参照法
配列リファレンスの0番目の要素を表示する（アロー記法）
```perl
my $array_ref = [ 'foo', 'bar', 'baz' ];    # 無名配列

# アロー記法
print "$array_ref->[0]\n";                  # foo
```

**アロー（矢印） `->` を利用した `$array_ref->[0]`** という記法で配列リファレンスの要素にアクセスすることが可能です。


___
## 練習問題(array_ref_for.pl)
以下のコードを実行するとエラーが出ます。エディタにコピペしたうえで**for文の{ }ブロック内を修正し**、プログラムを完成させてください。

余裕のある人は以下に挑戦してください
- アロー記法を使った方法、使わない方法で書いてみる
- for文の条件式と{ }ブロック内を編集して書いてみる

```perl
# お約束の3行は省略してますが、必ず書くこと

my $month_name = [
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
];
for my $num ( 0 .. 11 ) {
    print "$month_name";    # 月の省略した英名を表示する
}

```

---
# 配列リファレンスを使う

___
## 配列リファレンスを使う
以下のデータを配列リファレンスで処理してみましょう。

```
    [animal]
       ├────┬─ shiba
       │    └─ bull
       └────┬─ mike
            └─ kuro
```

animal という集合の中に 犬の集合（shiba, bull） と 猫の集合（mike, kuro） が入っている図とみてください。

配列の中の配列 です。

___
## 配列リファレンスを使う
まずはデータ構造を作成します。

配列のリファレンスを使うことで、意図した構造でデータを格納できます。

```perl
my @dog     = ( 'shiba', 'bull' );    # 配列@dogを作る
my $dog_ref = \@dog;                  # @dogをリファレンスにする

my $cat_ref = [ 'mike', 'kuro' ];   # 無名配列をつかって猫の配列リファレンスをつくる

my @animal  = ( $dog_ref, $cat_ref ); # @animal の要素に入れて完成
```

無名配列を使って、一度にまとめて書くこともできます。

```perl
my @animal = ( [ 'shiba', 'bull' ], [ 'mike', 'kuro' ] );    # 完成
```

___
## 配列リファレンスを使う
作成したデータ構造から、特定のデータ「bull」を表示します。
```
    [animal]
       ├──┬─ shiba
       │  └─ bull
       └──┬─ mike
          └─ kuro
```
1. 配列 `@animal` のどこに 犬の集合が入っているかを確認する<br>
    => `@animal` の 最初の要素に入っている。これは `$animal[0]` となる。<br>
    => この `$animal[0]` は スカラー値、つまり配列リファレンスである。

1. 次に, 配列リファレンスのどこに `bull` が入っているかを確認する。<br>
    => `[1]` 番目である。

1. `bull`が格納されているのは `${$animal[0]}[1]` または `$animal[0]->[1]` となる。

___
## 配列リファレンスを使う
では実際に表示してみます。
```perl
# 無名配列でデータ構造を構築
my @animal = ( [ 'shiba', 'bull' ], [ 'mike', 'kuro' ] );

print "$animal[0]->[1]\n";  # bull
```

また、添字に挟まれる場合に限り、アロー記法を省略することが可能です。
```perl
# 無名配列でデータ構造を構築
my @animal = ( [ 'shiba', 'bull' ], [ 'mike', 'kuro' ] );

print "$animal[0][1]\n";    # bull アローを省略
```

___
## 練習問題(animal_array_ref.pl)
```
    animal
       ├──┬─ shiba
       │  └─ bull
       │
       ├──┬─ mike
       │  └─ kuro
       │
       └──┬─ eagle
          └─ crow
```

次の処理をする `array_ref.pl` を作りましょう。

1. 上記のデータ構造を表す`@animal`を作ってください。

1. `@animal`の中にある`eagle`を表示してください。

1. 余裕があれば, 他の要素も表示してみましょう。

---
# ハッシュリファレンス

___
## ハッシュリファレンス
ハッシュのデータ構造も **ハッシュリファレンス** として扱うことができます。

___
## ハッシュリファレンス
では, さっそくハッシュをリファレンスにしてみます。

```perl
my %hash = (
    name => 'Larry',
    lang => 'Perl',
);

my $hash_ref = \%hash;
```

配列リファレンスと同様です。

- シジル( `%` ) の前にバックスラッシュ(\\)を置くことでリファレンスを作成できる

- リファレンスは **スカラー変数** に格納される

___
## ハッシュリファレンス
### リファレンスの中身
```perl
my %hash = (            # ハッシュを定義
    name => 'Larry',
    lang => 'Perl',
);

my $hash_ref = \%hash;  # ハッシュリファレンスを作成
print "$hash_ref\n";    # HASH(0x7f92de017760)
```

ここも配列リファレンスと同様です。

ハッシュリファレンスとは、ハッシュの要素が格納されているメモリの番地を指し示すものです。

ハッシュリファレンスの中の要素を利用するためには、**デリファレンス**する必要があります。

___
## ハッシュリファレンス
### デリファレンス
```perl
my %hash = (            # ハッシュを定義
    name => 'Larry',
    lang => 'Perl',
);

my $hash_ref = \%hash;  # ハッシュリファレンスを作成
my %deref_hash = %{$hash_ref}; # デリファレンス
```

デリファレンスの方法も、配列リファレンスと同じです。ただし、記号が異なります。

リファレンスが格納されている変数を **{ } （中括弧, curly bracket）で囲み**、元の変数のシジルをつけることでデリファレンスすることが可能です。

___
## ハッシュリファレンス
### デリファレンス
デリファレンスしたスカラー変数は、ハッシュと同様に key を使って元のハッシュの要素にアクセスできます。
```perl
my %hash = (    # ハッシュを定義
    name => 'Larry',
    lang => 'Perl',
);

my $hash_ref = \%hash;    # ハッシュリファレンスを作成

print ${$hash_ref}{name} . "\n";    # Larry
print ${$hash_ref}{lang} . "\n";    # Perl
```

___
## ハッシュリファレンス
### デリファレンス
先ほど出てきた `%{$hash_ref}{name}` について説明します。
```perl
    print ${$hash_ref}{name}  . "\n";    # Larry
```

1. `$hash_ref` ：スカラー変数（中身はハッシュリファレンス）

1. `%{$hash_ref}` ：スカラー変数をデリファレンスして、ハッシュと同様に扱えるようにする

1. `${$hash_ref}{name}` ：`name` という key に対応する１つの value にアクセスするので、シジルが $ に変わる

___
## 練習問題(hash_ref.pl)
以下のコードを実行するとエラーが出ます。エディタにコピペしたうえでプログラムを完成させてください。
```perl
# お約束の3行は省略してますが、必ず書くこと

my %hash = ( name => 'Larry', lang => 'Perl' ); # ハッシュを作成
my $hash_ref = \%hash;

print $hash_ref{name} . "\n";    # Larry と表示される
print $hash_ref{lang} . "\n";    # Perl と表示される
```

以下のように表示されれば正解です。まだアロー記法はつかわないこと！（この次にやります）
```
Larry
Perl
```


---
# ハッシュリファレンスの応用

___
## ハッシュリファレンスの応用
### 簡単な作り方
配列リファレンスの簡単な作り方に無名配列があったように、ハッシュも無名ハッシュからリファレンスを作ることができます。
```perl
    my $hash_ref = {
        name => 'Larry',
        lang => 'Perl',
    };
    print ${$hash_ref}{name};    # Larry
    print ${$hash_ref}{lang};     # Perl
```

無名ハッシュの「無名」はハッシュとしての名を持たない（`$hash_ref` はスカラーの名前）と考えてください。

通常のハッシュ作成時は `( )` を利用しますが、**無名ハッシュは `{ }` （中括弧, curly brackets）を利用して作成します。**

___
## ハッシュリファレンスの応用
### 簡単な参照法

- （参考）ハッシュの key を参照する
```perl
my %hash = ( name => 'Larry' );
print "$hash{name}\n";    # Larry
```

- （参考）ハッシュリファレンスの key を参照する（デリファレンスして添字）

```perl
my $hash_ref = { name => 'Larry' };    # 無名ハッシュ
print "${$hash_ref}{name}\n";          # Larry
```

___
## ハッシュリファレンスの応用
### 簡単な参照法
配列リファレンスの時と同様に、アロー記法を利用します。
```perl
my $hash_ref = {
    name => 'Larry',
    lang  => 'Perl',
};
print "$hash_ref->{name}\n";    # Larry
print "$hash_ref->{lang}\n";    # Perl
```

通常のハッシュのvalueを参照するときは $hash{key} ですが、**ハッシュリファレンスの場合には `->` がついて `$hash_ref->{key}`** となっています。

___
## 練習問題（hash_ref_for.pl）
以下のコードを実行すると意図した出力が行われません。エディタにコピペしたうえで**for文の{ }ブロック内を修正し**、プログラムを完成させてください。
```
Jan is 1
```
と12ヶ月分表示されれば正解です。余裕のある人は`1st month`, `2nd month` などの序数を正しく追加しましょう。

```perl
# お約束の3行は省略してますが、必ず書くこと
my @month_name = (
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
);
my $month_hash_ref = {
    Jan => 1, Feb => 2, Mar => 3, Apr => 4, May => 5, Jun => 6,
    Jul => 7, Aug => 8, Sep => 9, Oct => 10, Nov => 11, Dec => 12,
};
for my $name (@month_name){
    print $name . ' is ' . %month_hash_ref{$name} . "th month\n";
}
```

---
# ハッシュリファレンスを使う

___
## ハッシュリファレンスを使う
以下のデータ構造をハッシュリファレンスで処理してみましょう。
```
animal
   └─ dog
       ├─ name: 'Taro'
       └─ color: 'brown'
```

動物 `animal` というハッシュの key として犬 `dog` があり、その `dog` の value として「名前」と「色」がある。


ハッシュのハッシュ です

___
## ハッシュリファレンスを使う
まずはデータ構造を作成します。

ハッシュのリファレンスを使うことで、意図した構造でデータを格納できます。
```perl
my %dog = (    # ハッシュを作る
    name  => 'Taro',
    color => 'brown',
);

# %dogをもとにハッシュリファレンス$dog_refを作る
my $dog_ref = \%dog;

# dogをkey, $dog_ref を value とする %animal を作る
my %animal = ( dog => $dog_ref, );
```
無名ハッシュを使って、一度にまとめて書くこともできます。
```perl
my %animal = ( dog => { name => 'Taro', color => 'brown' } );
```

___
## ハッシュリファレンスを使う
作成したデータ構造から、特定のデータ `Taro`　を表示してみます。
```
animal
   └ dog
       ├─ name: 'Taro'
       └─ color: 'brown'
```

1. ハッシュ %animal のどこに `Taro` があるか確認する<br>
    => `dog` 以下にある

1. `dog` の value にあるハッシュリファレンスの key の値を確認する<br>
    => name という key だ

1. これらの情報から `Taro` が格納されているのは以下となる
    - `${$animal{dog}}{name}`
    - `$animal{dog}->{name}`

___
## ハッシュリファレンスを使う
では実際に表示してみます。

```perl
# 無名ハッシュで一気にデータ構造を構築
my %animal = ( dog => { name => 'Taro', color => 'brown' } );

print ${$animal{dog}}{name} , "\n";   # Taro
print $animal{dog}->{name} , "\n";    # Taro アロー記法
```

配列リファレンスと同様に、アローが添字に挟まれる場合にはアロー記法の省略が可能です。
```perl
my %animal = ( dog => { name => 'Taro', color => 'brown' } );

print $animal{dog}{name} , "\n";    # Taro
```

___
## 練習問題(animal_hash_ref.pl)

    animal
      ├─ dog
      │    ├─ name: 'Taro'
      │    └─ color: 'brown'
      └─ cat
           ├─ name: 'Tama'
           └─ color: 'white'

次の処理をする `animal_hash_ref.pl` を作りましょう。

ハッシュのハッシュ です。dog , cat はそれぞれkeyと考えてください。

1. 上記のデータ構造を表す`%animal`を作ってください。

1. `%animal`の中にある`white`を表示してください。

1. 余裕があれば, 他の要素も表示してみましょう。

---
# リファレンスの操作

___
## リファレンスの操作
### リファレンスへの追加/削除は・・・？
リファレンスのままでは、追加/削除はできません。リファレンスはあくまで、データを指し示すスカラー値だからです。

しかし、デリファレンスすることで、これまでに習った配列操作関数やハッシュ操作関数を利用することができます。

___
## リファレンスの操作
### 配列リファレンスへの操作例

```perl
my $array_ref = [ 'foo', 'bar', 'baz' ];    # 無名配列を作成
print "@{$array_ref}" . "\n"; # foo bar baz

push @{$array_ref}, 'piyo';   # デリファレンスして piyo を末尾に追加
print "@{$array_ref}" . "\n"; # foo bar baz piyo

shift @{$array_ref};          # デリファレンスして foo を取り出し
print "@{$array_ref}" . "\n"; # bar baz piyo
```

___
## リファレンスの操作
### ハッシュリファレンスへの操作例
```
my $hash_ref = {
    name => 'Larry',
    lang => 'Perl',
};

${$hash_ref}{univ} = 'SPU';      # デリファレンスして追加
print $hash_ref->{univ} . "\n";  # SPU （Seattle Pacific University）

my @keys = keys %{$hash_ref};    # デリファレンスしてkeyを取得
print "@keys" . "\n";            # name lang univ （順不同）

delete ${$hash_ref}{univ};       # デリファレンスしてunivを削除
if ( exists ${$hash_ref}{univ} ){# デリファレンスしてunivが存在するか確認
    print "univ is exists\n"
}else{
    print "univ is not exists\n"
}
```

---
# 便利モジュール

___
## 便利モジュール
### リファレンスの中身を全部見たい
データ構造の中身を出力したいとき、ここまではその要素の一部だけを表示きました。

しかし、中身を一度にすべて見たい場合はどうすればいいでしょうか？

___
## 便利モジュール
### Data::Dumper
このようなときは、`Data::Dumper` モジュールを使えばリファレンスの中身を一括表示（ダンプ）できます。
```perl
use Data::Dumper; # 最初にモジュールの使用を宣言
my $dog = {
    name => 'Taro',
    color => 'brown',
};
$dog->{age} = 3;
print Dumper($dog); # Data::Dumper の Dumper 関数を使って print

# 出力結果
# $VAR1 = {
#         'name' => 'Taro',
#         'color' => 'brown',
#         'age' => 3
#         };
```
___
## Data::Dumperを使う
`Data::Dumper` にはリファレンスを引数として渡します。

よって、ハッシュの中身を見たいときには、リファレンスにしたものを渡します。
```perl
my %dog = (
    name => 'Taro',
    color => 'brown',
);
$dog{age} = 3;

print Dumper(\%dog); # リファレンスを渡す
```

`Data::Dumper` は、新たな要素を代入した後に中身を確かめたいときや、データの中身を把握していないときなどに役立ちます。

また、Perlに標準で組み込まれているモジュールなので、宣言さえすれば利用することが可能です。

___
## Perlとモジュール
Perlには`Data::Dumper`の他にも有用なモジュールが標準で数多く組み込まれています。
その一部を紹介します。

- `Encode`
    - 日本語などの「マルチバイト文字」入出力に必須となるモジュール。絵文字も利用可能。
- `JSON::PP`
    - インターネットでの情報のやり取りに利用される「JSON形式」データの作成・解読。(Perl 5.14以降)
- `List::Util`
    - リスト(配列)でよく利用される最小, 最大, 合計など、よく利用する関数を提供。
- `HTTP::Tiny`
    - 必要最小限の機能を持つWebクライアント。(Perl 5.14以降)

___
## 練習問題(`region_ref.pl`)

まず, 以下のデータ構造を表す`%japan`を作ってください.

```
japan
 ├─ tokyo
 │    ├─ gotanda
 │    └─ shibuya
 ├─ osaka
 │    └─ shinsaibashi
 ├─ okinawa
 │    ├─ naha
 │    └─ yomitan
 ├─ hokkaido
 │    ├─ sapporo
 │    └─ obihiro
 └─ fukuoka
       └─ hakata
```

___
## 練習問題
1. 作成したデータから `tokyo` に含まれる `gotanda`, `shibuya`を表示してください

1. 作成したデータの `osaka` に `umeda`を追加してください

1. 作成したデータの `okinawa` に `piyo`を追加してください

1. 作成したデータの `hokkaido` に `chitose`を追加し, `sapporo`を取り除いてください（今までに習った配列操作関数 push,pop,shift,unshift を利用しましょう。`sapporo`の位置に注目）

1. 作成したデータの `fukuoka` を取り除いてください

1. Data::Dumperでデータ構造を表示してください

1. 時間の余裕のある人は、Data::Dumper を使わずに `%japan` 内のデータを全て表示してみましょう

1. さらに時間の余裕がある人は`splice`関数について調べてみましょう


---
## 復習問題
- <https://github.com/perl-entrance-org/workshop-2019/blob/master/4th/practice.md>

今回の内容を復習できる問題集です.

不明点があれば, 気軽にサポーターに質問してください.

- 是非Perl入学式の[slack](https://docs.google.com/forms/d/e/1FAIpQLScbWyg-cgcqilW7-BpKagRm2ldBhvwRBNr2N5eg3LHOK13FGw/viewform)に参加して, サポーターや参加者の皆さんと交流しましょう．

- 不明点もslackで是非質問してください.

- 最終回の第5回の参加もお待ちしております!

---
## HTML入学式
次回はWebアプリを作成しますが、その際に知っておくと良い内容をまとめました。

- <https://github.com/perl-entrance-org/workshop-2019/blob/master/4th/html_entrance.md>

---
# 次回予告
- サブルーチン

- Mojolicious の準備

- HTTP の基礎

- Mojolicious 入門

- 簡易 BBS の作成
